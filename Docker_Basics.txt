Docker Basics
==============

By docker it is easier for tester to test software from developer


Container
-----------

    * A way to package an application with all necessary dependencies and configuration
    * It can be easily shared
    * Makes deployment & development efficient


Architecture of Docker
-----------------------

    Hardware -> OS -> Docker Engine -> Container

    There can be multiple docker containers

    Hardware -> OS -> Docker Engine -> Container (v1)  version 1 
                                    -> Container (v2)  version 2


Docker Container Vs VMs
-----------------------

    Docker Container -> Low impact on OS, very fast, low disk space usage
    VMs              -> High impact on OS, slower, high disk space usage
    
    Docker Container -> Sharing, rebuilding & distribution is easy 
    VMs              -> Sharing, rebuilding & distribution is challenging
    
    Docker Container -> Encapsulate apps instead of whole machine  
    VMs              -> Encapsulate whole machine


Main Components of Docker
--------------------------

    * Docker File
    * Docker Image
    * Docker Container
    * Docker Registry 

See Image Docker_Basics.png



Docker Register 
---------------- 
    is central repository for storing & distributing Docker images



Note ->  A registry is a centralized location that stores and manages container images, whereas a repository is a collection of related container images within a registry. 


Also remember that docker file doesn’t have an extension it is just written DockerFile without extension



use -> FROM ---
    ex -> FROM node
use version number like -> FROM <repository_name>:<n>
    ex -> FROM node:20



*      docker run -p host_port:container_port <image-id>
        p means here container port publish a container's port to the host

    host_port: The port on the host machine.
    container_port: The port inside the Docker container.

* We can't bind the same host port to multiple Docker containers simultaneously otherwise port conflict error will come.

* -d (Detach Mode)
    Purpose: The -d flag is used to run the Docker container in detached mode.
    Behavior: When a container is started in detached mode, it runs in the background, and the command prompt returns immediately.


  -p (Port Mapping)
    Purpose: The -p flag is used to map ports from the host machine to the Docker container.


Doing changes to project (fixing bug, updates):  
    we can just do new tag version 2



Push Image in DockerHub
======================= 
    We can upload our image in docker hub, other team can download from there

    You can create in   hub.docker.com  and create repository 

    You can push new tag -> docker push <userid>/<repo-name>:tagname 

    You have to login using docker login on terminal -> docker login

    To push with online <userid>/<repo-name> you have to first build the image then push possible 
    Just like github you can push in docker -> 
        ex -> docker build -t pranjalkumar09/webapp-demo:01 .

    docker push <userid>/<repo-name> 
        ex-> docker push pranjalkumar09/webapp-demo:01

    When we push different tag/version of image in docker then we might see coming "Layer already exists" coming in terminal this shows how docker smartly link same thing


Docker Pulling
==============
    To pull online docker image in remote system => docker pull <userid>/<repo-name>
                docker pull pranjalkumar09/webapp-demo:02

    Now we can even make container for this 


Docker Volume 
=============
    Now if we make container python program which includes something like showing a file it will changes happen during just that program    ex: see python_project folder
    run its container -> python_project$ docker run -it --rm --name mypythonapp ad1add67b5af

    So docker volume needed-> docker run -it --rm -v myvolume:/myapp/ ad1add67b5af

    now all changes on file will visible, in docker volume.


Help -> by   --help   we will get any help information regarding commands.
==================================



Mount Binds
=========== 
    When we want to see changes done by ourselves in file and we want that it appears in file
    like in      python_project03

    new updates will not appear this, we can new update in file by     => docker run -v "/media/pranjal/New Volume/CODES/Public/Docker&Github/python_project3/servers.txt:/myapp/servers.txt" --rm dd55adccd99f 

    docker run -v "/path/on/host:/path/in/container" --rm image_name


    new changes will appear here but not in above case

    also note that in this it is not docker volume so it will not visible in docker

Dockerignore
============
    can be created in same file where docker image     .dockerignore
    Like .gitignore  it supports everything 

    We don’t need Dockerimage generally but it is important so we can put it in .dockerignore


Working with API
================
    When you import some module in Docker container it still didn’t run, because container has no external dependencies

    To run external dependencies in it simply add  RUN pip install requests 
    Then run it 

    Now it will run imported thing

Container with local DB 
======================== 
    When we connect database to program and copy program in docker and run its container cause error to (see "Container_with_local_DB" ) host.docker.internal
    Then to deal with this error we will change this in line 6
         host="localhost"   to   host="host.docker.internal"

    Then in new container it will not cause error and it will access the database




Docker Network
==============
    --network <network-name>

    in any python program like in like connecting to database   in the   host name   we have put our     <container-name>



Docker Compose
==============
    Configuration file to manage multiple container running on same machine
    Usually composing a program

    docker run -d --env MYSQL_ROOT_PASSWORD="root" --env MYSQL_DATABASE="userinfor" --name mysqldb --network my-net mysql 

    Like this command typing it again is not efficient so to tackle it 
        Make     docker-compose.yml    file
    
        in this 
            services:  #which means container

    Now to access images in docker-compose.yml  we have to docker-compose up 

     (must delete any previous docker image with same name is name given in docker container.yml)


    docker compose down : remove docker container (without --rm)

    To run it in detach mode: docker-compose up -d



    Docker Compose with Multiple Containers
    --------------------------------------
        Docker compose is a config file to make your task of managing and running containers easy

        we can out multiple containers
            what is normally 

        but there can be dependencies means we want certain container to first 
        then we can put   "depends-on" where we will run it if health check of depended container is done


        When we run only single image (from docker-compose run <name>) then if it depends it run dependencies also, also it will create network (if not created by default) then by this it will run dependencies 

        Network by => networks:

        and if you create any python file connected with file then you can created by volumes
            like volumes: 
                - <path>

            note path not needed for docker-compose

            you can also give -port
                    like     ports:
                                - <host_port>:<container_port>
